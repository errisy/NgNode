//console.log('loading Serializable...');
//how to write this code?
//for server 'serializable' is an internal module, it will be loaded at the time of running.

//Pseudo Imports for NodeJS
import * as NodeFS from 'fs';
import * as NodeVM from 'vm';

import {Response } from '@angular/http';


//should work for both nodeJS and browser
let __relativeRoot: string;
let DynamicRequire: (filename: string, pathname: string, callback: (exported: any) => void) => void;
export module Path {
    export function Reduce(path: string) {
        return path.replace(/[^\\^\/^\:]+[\\\/]+\.\.[\\\/]+/ig, '').replace(/([^\:])[\\\/]{2,}/ig, (capture: string, ...args: string[]) => {
            return args[0] + '\/';
        }).replace(/\.[\\\/]+/ig, '');
    }
    export function getFilename(path: string) {
        let index = Math.max(path.lastIndexOf('\\'), path.lastIndexOf('\/'));
        if (index > -1) return path.substr(index + 1);
        return path;
    }
    export function getPathname(path: string) {
        let index: number = Math.max(path.lastIndexOf('\\'), path.lastIndexOf('\/'));
        //console.log('[pathreducer]->pathaname: ', path, index, path.length);
        if (index > -1) return path.substr(0, index + 1);
        return path;
    }
    export function toPathname(path: string) {
        let index: number = Math.max(path.lastIndexOf('\\'), path.lastIndexOf('\/'));
        //console.log('[pathreducer]->pathaname: ', path, index, path.length);
        if (index > - 1) return path.substr(0, index + 1);
        return path;
    }
}

class AsyncRequireStringLoader {
    constructor(private requiring: { [id: string]: any }) {
    }
    private keys: string[] = [];
    public require = (key:string, filename: string, pathname: string) => {
        this.keys.push(key);
        DynamicRequire(filename, pathname, this.loaded(key));
    }
    private loaded = (key: string) => {
        let that = this;
        return (exported: any) => {
            that.requiring[key] = exported;
            that.keys.splice(this.keys.indexOf(key), 1);
            if (that.keys.length == 0 && that.allRequired) {
                that.onLoadCompleted(that.requiring);
            }
        }
    }
    public completeRequire = () => {
        this.allRequired = true;
        let that = this;
        if (this.keys.length == 0 && this.allRequired) {
            that.onLoadCompleted(this.requiring);
        }
    }
    private allRequired: boolean = false;
    /**
     * For run code after loading.
     */
    public onLoadCompleted: (completedObject: { [id: string]: any }) => void;
}
class AsyncRequireNumberLoader {
    constructor(private requiring: { [id: number]: any }) {
    }
    private keys: number[] = [];
    public require = (key: number, filename: string, pathname: string) => {
        this.keys.push(key);
        DynamicRequire(filename, pathname, this.loaded(key));
        console.log('Aysnc: ', pathname, filename);
    }
    private loaded = (key: number) => {
        let that = this;
        return (exported: any) => {
            that.requiring[key] = exported;
            that.keys.splice(this.keys.indexOf(key), 1);
            if (that.keys.length == 0 && that.allRequired) {
                that.onLoadCompleted(that.requiring);
            }
        }
    }
    public completeRequire = () => {
        this.allRequired = true;
        if (this.keys.length == 0 && this.allRequired) {
            this.onLoadCompleted(this.requiring);
        }
    }
    private allRequired: boolean = false;
    /**
     * For run code after loading.
     */
    public onLoadCompleted: (completedObject: { [id: number]: any }) => void;
}

if (!console['Console']) {
    //Client Browser: window.document is defined
    __relativeRoot = '';

    class fs {
        static readFile(filename: string, callback: (data: string) => void) {
            let xmlRequest = new XMLHttpRequest();
            xmlRequest.overrideMimeType("text/plain");
            xmlRequest.onreadystatechange = (ev) => {
                if (xmlRequest.readyState == 4) {
                    if (xmlRequest.status == 200) {
                        console.log('fs.readFile callback');
                        callback(xmlRequest.responseText);
                    } else {
                    }
                }

            }
            xmlRequest.onerror = ev => {
                console.log('XMLHttpRequest Error', ev);
            };
            xmlRequest.open('GET', filename, true);
            xmlRequest.send(null);

            console.log('fs.readFile sent: ', filename);
        }
    }
    /**
     * Implementation of Node vm at client side;
     */
    class vm {
        static createContext(contextObj: any) {
            return new VMContext(contextObj);
        }
        static createScript(code: string): VMScript {
            return new VMScript(code);
        }
    }
    class VMContext {
        constructor(private contextObj: any) {
        }
        get Context(): { [id: string]: any } {
            return this.contextObj;
        }
    }
    class VMScript {
        constructor(private code: string) {

        }
        public runInContext = (context: VMContext): Function => {
            let contextCode: string[] = [];
            for (let key in context.Context) {
                contextCode.push('\t\tlet ' + key + ' = $__injectedContext["' + key + '"];\n');
            }
            let script = '({\n' +
                '\tmethod: function($__injectedContext){\n' +
                contextCode.join('') +
                '\t\treturn function(){\n\t\t\ttry{\n\t\t\t\tvar exports = {};\n' +
                this.code +
                '\n\t\t\t\treturn exports;\n\t\t}\n' +
                '\t\t\tcatch(ex){\n\t\t\tconsole.log("Dynamic Require Error:", ex);\n\t\t\t}\n' +
                '\t\t}\n' +
                '\t}\n' +
                '})';
            //console.log(script);
            return eval(script).method(context.Context);
        }
    }

    DynamicRequire = (fileName: string, directoryName: string, callback: (exported: any) => void) => {
        try {
            if (!directoryName) directoryName = __relativeRoot;
            console.log('DynamicRequire: ', fileName, ' Base Path: ' + directoryName);
            let required: { [id: number]: any } = {};
            let requiredIndex: number = 0;
            let fullFilename: string = Path.Reduce(directoryName + '//' + fileName);
            let dependencyLoader = new AsyncRequireNumberLoader(required);
            fs.readFile(fullFilename, (data) => {
                //console.log('readFile data: ', data);
                if (!data) throw 'Script file ' + fullFilename + ' can not be loaded by Dynamic Require.';
                let code = //'(function (){\ntry{\n\tvar exports = {};\n' +
                    data.replace(/require\s*\(\s*[\'"]([\/a-z_\-\s0-9\.]+)[\'"]\s*\)/ig, (capture: string, ...args: any[]) => {
                        console.log('hit: ', capture);
                        let $modulePath: string = args[0];
                        let $file: string;
                        if ($modulePath.charAt[0] == '.') {
                            $file = Path.Reduce(directoryName + '//' + args[0] + '.js');
                        }
                        else {
                            $file = Path.Reduce(directoryName + '/node_modules/' + args[0] + '/index.js');
                        }
                        dependencyLoader.require(requiredIndex, Path.getFilename($file), Path.toPathname($file));
                        let replacement = '$__required[' + requiredIndex + ']';
                        requiredIndex += 1;
                        return replacement;
                    }).replace(/require\s*\(\s*[\'"]Serializable[\'"]\s*\)/ig, (capture: string, ...args: any[]) => {
                        return '$__serializable';
                    });//+
                    //'\n\treturn exports;\n}\ncatch(ex){\n\tconsole.log("Error:", ex, "@' + fullFilename.replace(/\\/ig, '\\\\') + '");\n}\n})';
                let _script = vm.createScript(code);
                dependencyLoader.onLoadCompleted = (finished) => {
                    let context = vm.createContext({
                        $__required: finished,
                        $__serializable: exports
                    });
                    let fn: Function = _script.runInContext(context);
                    let exported: any = fn();
                    if (!exported) console.log('Exported is undefined: ', fullFilename);
                    if (exported['__relativeRoot']) exported['__relativeRoot'] = __relativeRoot;
                    console.log('exported: ', exported);
                    callback(exported);
                };
                dependencyLoader.completeRequire();
            });
        }
        catch (ex) {
            console.log('dynamicRequire Error: ', ex);
        }
    }
}
else {
    //NodeJS
    //console.log('loading Node Modules', __dirname.length);
    __relativeRoot = __dirname;
    //eval must be used here as the AMD loader can recognize require and processes it before the script is running;
    let fs: typeof NodeFS = eval('require("fs")');
    let vm: typeof NodeVM = eval('require("vm")');
    DynamicRequire = (fileName: string, directoryName: string, callback: (exported: any) => void) => {
        try {
            if (!directoryName) directoryName = __relativeRoot;
            console.log('DynamicRequire: ', fileName, ' Base Path: ' + directoryName);
            let required: { [id: number]: any } = {};
            let requiredIndex: number = 0;
            let fullFilename: string = Path.Reduce(directoryName + '//' + fileName);
            let dependencyLoader = new AsyncRequireNumberLoader(required);

            if (fs.existsSync(fullFilename)) {
                if (fs.statSync(fullFilename).isFile()) {
                    let code = '(function (){\ntry{\n\tvar exports = {};\n' +
                        fs.readFileSync(fullFilename).toString()
                            .replace(/require\s*\(\s*[\'"](\.+[\/a-z_\-\s0-9\.]+)[\'"]\s*\)/ig, (capture: string, ...args: any[]) => {
                                let $file = Path.Reduce(directoryName + '//' + args[0] + '.js');
                                //required[requiredIndex] = DynamicRequire(Path.getFilename($file), Path.toPathname($file));
                                dependencyLoader.require(requiredIndex, Path.getFilename($file), Path.toPathname($file));
                                let replacement = '$__required[' + requiredIndex + ']';
                                requiredIndex += 1;
                                return replacement;
                            }) +
                        '\n\treturn exports;\n}\ncatch(ex){\n\tconsole.log("Error:", ex, "@' + fullFilename.replace(/\\/ig, '\\\\') + '");\n}\n})';

                    let _script = vm.createScript(code);
                    dependencyLoader.onLoadCompleted = (finished) => {
                        let context = vm.createContext({
                            console: console,
                            require: require,
                            __dirname: directoryName,
                            __filename: __filename,
                            process: process,
                            $__required: finished
                        });
                        let fn: Function = _script.runInContext(context);
                        let exported: any = fn();
                        if (!exported) console.log('Exported is undefined: ', fullFilename);
                        if (exported['__relativeRoot']) exported['__relativeRoot'] = __relativeRoot;
                        callback(exported);
                    }
                }
                else {
                    console.log('dynamicRequire Error: File not found - ' + fullFilename);
                }
            }
            else {
                console.log('dynamicRequire Error: File not found - ' + fullFilename);
            }
        }
        catch (ex) {
            console.log('dynamicRequire Error: ', ex);
        }
    }
}

/**
 * You must provide a Module Name for the this Serializable decorator. It uses the Module Name to deserialize the object.
 * @param moduleName
 */
export function Serializable(moduleName: string) {
    return (target: any) => {
        // save a reference to the original constructor
        var original: Function = target;
        // a utility function to generate instances of a class
        function construct(constructor: Function, args: any[]) {
            var c: any = function () {
                return constructor.apply(this, args);
            }
            c.prototype = constructor.prototype;
            let instance: { [id: string]: string } = new c();
            instance['@Serializable.ModuleName'] = moduleName;
            instance['@Serializable.TypeName'] = original.name;
            return instance;
        }
        // the new constructor behaviour
        var f: any = function (...args: any[]) {
            console.log("New: " + original.name + " : Serializable");
            return construct(original, args);
        }
        // copy prototype so intanceof operator still works
        f.prototype = original.prototype;

        // return new constructor (will override original)
        return f;
    }
}

// References is the dictionary that hold all loaded library;
var References: { [id: string]: { [id: string]: ObjectConstructor } } = {};
var __moduleRoot: string;
/**
 * This path is determined by path.dirname(require.main.filename). If you want to changed the default value, set a new value to it after require/import.
 */

class ObjectDeserializer {
    constructor(private jsonObject: any, private callback: (deserialized: any) => void) {
        if (typeof jsonObject != 'object') {
            this.result = jsonObject;
            this.start();
            return;
        }
        if (jsonObject['@Serializable.ModuleName'] && jsonObject['@Serializable.TypeName']) {
            console.log('Deserialize Object: ', JSON.stringify(jsonObject));
            let moduleName: string = jsonObject['@Serializable.ModuleName'];
            let typeName: string = jsonObject['@Serializable.TypeName'];
            //load module to References
            if (moduleName.charAt(0) == '/') {
                // this is a relative file;
                // if the module was not loaded, load it from the module file;
                //console.log('__relativeRoot: ', __relativeRoot);
                if (!References[moduleName]) {
                    let $file = Path.Reduce(__relativeRoot + moduleName + '.js');
                    console.log('Deserialize->Load Type Def from: ', $file);
                    DynamicRequire(Path.getFilename($file), Path.toPathname($file), this.onObjectBuild(moduleName, typeName));
                }
                else {
                    console.log('Deserialize->Module has been loaded: ', moduleName);
                    this.onObjectBuild(moduleName, typeName)(References[moduleName]);
                }
            }
            else {
                //this is a built-in module
                //this.onObjectBuild(moduleName, typeName)(require(moduleName));
                if (!References[moduleName]) {
                    let $file = Path.Reduce(__relativeRoot + '/node_modules/' + moduleName + '/index.js');
                    console.log('Deserialize->Load Type Def from: ', $file);
                    DynamicRequire(Path.getFilename($file), Path.toPathname($file), this.onObjectBuild(moduleName, typeName));
                }
                else {
                    console.log('Deserialize->Module has been loaded: ', moduleName);
                    this.onObjectBuild(moduleName, typeName)(References[moduleName]);
                }

            }
            return;//stop here if it needs to built from libs;
        }
        if (!this.result && Array.isArray(jsonObject)) this.result = [];
        //if it is a plain object, we will deserialize the properties only;
        //this won't work if there is no properties;
        this.DeserializeIndices();
        this.DeserializeProperties();
        this.start();
    }
    private onObjectBuild = (moduleName: string, typeName: string) => {
        let that = this;
        return (exported: any) => {
            References[moduleName] = exported;
            console.log('moduleName.typeName: ', moduleName, typeName, References[moduleName][typeName]);
            that.result = new References[moduleName][typeName]();
            that.DeserializeProperties();
            that.DeserializeIndices();
            that.start();
        }
    }
    private DeserializeProperties = () => {
        for (let property in this.jsonObject) {
            this.properties.push(property);
            console.log('Deserialize property: ', property);
            //Deserialize(this.jsonObject[property], this.onPropertyDeserialized(property));
            new ObjectDeserializer(this.jsonObject[property], this.onPropertyDeserialized(property));
        }
    }
    private DeserializeIndices = () => {
        if (!Array.isArray(this.jsonObject)) return; //guard here;
        for (let i = 0; i < (<any[]>this.jsonObject).length; i++) {
            this.indices.push(i);
            console.log('Deserialize index: ', i);
            //Deserialize((<any[]>this.jsonObject)[i], this.onIndexDeserialized(i));
            new ObjectDeserializer((<any[]>this.jsonObject)[i], this.onIndexDeserialized(i));
        }
    }
    private onIndexDeserialized = (index: number) => {
        return (deserialized: any): void => {
            console.log('index deserialized: ', index, deserialized);
            (<any[]>(this.result)).push(deserialized);
            this.indices.splice(this.indices.indexOf(index), 1);
            this.invokeCallback();
        }
    }
    private onPropertyDeserialized = (property: string) => {
        return (deserialized: any) => {
            console.log('prorperty deserialized: ', property, deserialized);
            this.result[property] = deserialized;
            this.properties.splice(this.properties.indexOf(property), 1);
            this.invokeCallback();
        }
    }
    private result: any;
    private indices: number[] = [];
    private properties: string[] = [];
    private started = true;
    public start = () => {
        this.started = true;
        console.log('Deserialization started.');
        this.invokeCallback();
    }
    private invokeCallback = () => {
        console.log('try invoke callback.');
        if (this.indices.length == 0 && this.properties.length == 0 && this.started) {
            console.log('result: ', this.result);
            this.callback(this.result);
        }
    }
}
/**
 * Deserialize object and invoke the callback when object is loaded;
 * @param jsonObject The object that needs to be deserialized.
 * @param callback The call back function that provides the deserialized object.
 */
export function Deserialize(jsonObject: any, callback: (deserialized: any) => void): any {
    new ObjectDeserializer(jsonObject, callback);
}


/**
 * Register a member in a rpcService to work as cgi method;
 * @param target
 * @param propertyKey
 */
export function rpcMember(
    target: Object, // The prototype of the class
    propertyKey: string//,  The name of the method
    //descriptor: TypedPropertyDescriptor<any>
): void {
    //console.log("MethodDecorator called on: ", target, propertyKey);
    //return descriptor;
}
/**
 * Register a class as rpcService so it will be converted to .service.ts and .cgi.ts by rpc service compiler;
 * the .cgi.ts will wrap the service to process http requests;
 * @param target
 */
export function rpcService(target: Object) {
    //doing nothing here;
}

export class Converter {
    /**
     * Convert string to string;
     * @param res
     */
    static convertStringResponse(res: Response): string {
        return res.text();
    }
    /**
     * Convert response to json;
     * @param res
     */
    static convertJsonResponse(res: Response): any {
        return res.json();
    }
    /**
     * Convert response from text to number value;
     * @param res
     */
    static convertNumberResponse(res: Response): number {
        return Number(res.text());
    }
    /**
     * Convert response from text to boolean value;
     * @param res
     */
    static convertBooleanResponse(res: Response): boolean {
        return Boolean(res.text());
    }
}

export interface ITaskHost {
    /** create a task with job file name, args and obj.
     * @param job is the filename. the server will automatically add '.sys.js' to the end of it.
     * @param args is the startup argument,
     * @param obj is the first message that the master process will send to the child process.*/
    createTask: (job: string, args: string[], obj: any) => string;
    cancelTask: (id: string) => void;
    checkStatus: (id: string) => ITaskInfo;
}
export interface ITaskInfo {
    id: string;
    filename: string;
    status: 'Scheduled' | 'Running' | 'Error' | 'Completed';
    progress: string;
    /**start time in milliseconds from 1970-1-1 00:00:00*/
    starttime: number;
    /**start time in milliseconds from 1970-1-1 00:00:00*/
    endtime: number;
}

export interface IAsync {
    (): void;
}
/**
 * A class that can help run code in a async mode.
 */
export class async {
    public statements: IAsync[] = [];
    public run(statement: () => void) {
        this.statements.push(
            () => {
                statement();
                this.next();
            }
        );
        if (this.canRun) this.next();
    }
    public await<T>(statement: (callback: (value: T) => void) => void, setter: (value: T) => void) {
        this.statements.push(
            () => {
                statement((value: T) => {
                    setter(value);
                    this.next();
                });
            }
        );
        if (this.canRun) this.next();
    }
    public canRun: boolean = true;
    public next() {
        if (this.statements.length > 0) {
            let ia = this.statements.shift();
            this.canRun = false;
            ia();
        }
        else {
            this.canRun = true;
        }
    }
}
@Serializable('Serializable')
export class TaskInfo {
    public id: string;
    public filename: string;
    public status: 'Scheduled' | 'Running' | 'Error' | 'Completed';
    public progress: string;
    /**start time in milliseconds from 1970-1-1 00:00:00*/
    public starttime: number;
    /**start time in milliseconds from 1970-1-1 00:00:00*/
    public endtime: number;
    public args: string[];
    public obj: any;
}

//for NodeJS
if (module) {
    module.exports = exports;
}

